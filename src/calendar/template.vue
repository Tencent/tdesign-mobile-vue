<template>
  <div ref="templateRef" :class="{ [`${name}`]: true, [`${name}--popup`]: usePopup }">
    <div :class="`${name}__title`">
      <slot name="title">{{ title || globalConfig.title }}</slot>
    </div>
    <CloseIcon v-if="usePopup" :class="`${name}__close-btn`" size="24" @click="handleClose" />
    <div :class="`${name}__days`">
      <div v-for="(item, index) in days" :key="index" :class="`${name}__days-item`">{{ item }}</div>
    </div>
    <div :class="`${name}__months`" style="overflow: auto">
      <template v-for="(item, index) in months" :key="index">
        <div :class="`${name}__month`">
          {{ t(globalConfig.monthTitle, { year: item.year, month: globalConfig.months[item.month] }) }}
        </div>
        <div :class="`${name}__dates`">
          <div v-for="emptyItem in (item.weekdayOfFirstDay - firstDayOfWeek + 7) % 7" :key="emptyItem"></div>
          <template v-for="(dateItem, dateIndex) in item.months" :key="dateIndex">
            <div
              :class="{
                [`${name}__dates-item`]: true,
                [`${name}__dates-item--${dateItem.type}`]: !!dateItem.type,
                [`${dateItem.className ?? ''}`]: true,
              }"
              @click="handleSelect(item.year, item.month, dateItem.day, dateItem)"
            >
              <slot name="cell" :item="dateItem">
                <div v-if="dateItem.prefix" :class="`${name}__dates-item-prefix`">{{ dateItem.prefix }}</div>
                {{ dateItem.day }}
                <div
                  v-if="dateItem.suffix"
                  :class="{
                    [`${name}__dates-item-suffix`]: true,
                    [`${name}__dates-item-suffix--${dateItem.type}`]: !!dateItem.type,
                  }"
                >
                  {{ dateItem.suffix }}
                </div>
              </slot>
            </div>
          </template>
        </div>
      </template>
    </div>
    <div v-if="usePopup" class="t-calendar__footer">
      <slot name="confirmBtn">
        <template v-if="confirmBtn && typeof confirmBtn === 'object'">
          <t-button block theme="primary" v-bind="confirmBtn" @click="handleConfirm" />
        </template>
      </slot>
    </div>
  </div>
</template>

<script lang="ts">
import { defineEmits, defineExpose, computed, watch, inject, ref, toRaw } from 'vue';
import { CloseIcon } from 'tdesign-icons-vue-next';
import TButton from '../button';
import config from '../config';
import { TdCalendarProps, TDate, TDateType } from './type';
import { useConfig } from '../config-provider/useConfig';

const { prefix } = config;
const name = `${prefix}-calendar`;

export default {
  name,
  components: {
    TButton,
  },
};
</script>

<script setup lang="ts">
const { t, globalConfig } = useConfig('calendar');
const emit = defineEmits(['visible-change']);

const props = inject('templateProps') as TdCalendarProps;
// 获取时间年月日起
const getYearMonthDay = (date: Date) => {
  return {
    year: date.getFullYear(),
    month: date.getMonth(),
    date: date.getDate(),
  };
};

const title = computed(() => props.title);
const usePopup = computed(() => props.usePopup);
const templateRef = ref(null);
const valueRef = ref(props.value);
const selectedDate = ref();
const firstDayOfWeek = computed(() => props.firstDayOfWeek || 0);
const days = computed(() => {
  const raw = globalConfig.value.weekdays;
  const ans = [];
  let i = firstDayOfWeek.value % 7;

  while (ans.length < 7) {
    ans.push(raw[i]);
    i = (i + 1) % 7;
  }

  return ans;
});
const today = new Date();
const minDate = computed(() => (props.minDate ? new Date(props.minDate) : today));
const maxDate = computed(() =>
  props.maxDate ? new Date(props.maxDate) : new Date(today.getFullYear(), today.getMonth() + 6, today.getDate()),
);

// 获取日期
const getDate = (year: number, month: number, day: number) => new Date(year, month, day);

const confirmBtn = computed(() => {
  if (typeof props.confirmBtn === 'string') return { content: props.confirmBtn || globalConfig.value.confirm };
  return props.confirmBtn;
});

// 选择日期
const handleSelect = (year: number, month: number, date: number, dateItem: TDate) => {
  if (dateItem.type === 'disabled') return;
  const selected = new Date(year, month, date);

  if (props.type === 'range' && Array.isArray(selectedDate.value)) {
    if (selectedDate.value.length === 1) {
      if (selectedDate.value[0] > selected) {
        selectedDate.value = [selected];
      } else {
        selectedDate.value = [selectedDate.value[0], selected];
      }
    } else {
      selectedDate.value = [selected];
      if (!confirmBtn.value && selectedDate.value.length === 2) {
        props.onChange?.(selectedDate.value);
      }
    }
  } else if (props.type === 'multiple') {
    const newVal = [...selectedDate.value];
    const index = selectedDate.value.findIndex((item: Date) => isSameDate(item, selected));
    if (index > -1) {
      newVal.splice(index, 1);
    } else {
      newVal.push(selected);
    }
    selectedDate.value = newVal;
  } else {
    selectedDate.value = selected;
    if (!confirmBtn.value) {
      props.onChange?.(selectedDate.value);
    }
  }
  props.onSelect?.(toRaw(selectedDate.value));
};
// 确认
const handleConfirm = () => {
  emit('visible-change');
  props.onClose?.('confirm-btn');
  props.onConfirm?.(toRaw(selectedDate.value));
};
const handleClose = () => {
  emit('visible-change');
  props.onClose?.('close-btn');
};

const getMonthDates = (date: Date) => {
  const { year, month } = getYearMonthDay(date);
  const firstDay = getDate(year, month, 1);
  const weekdayOfFirstDay = firstDay.getDay();
  const lastDate = new Date(+getDate(year, month + 1, 1) - 24 * 3600 * 1000).getDate();

  return {
    year,
    month,
    weekdayOfFirstDay,
    lastDate,
  };
};
type CompareDate = Date | number | { year: number; month: number; date: number };
const isSameDate = (date1: CompareDate, date2: CompareDate) => {
  if (date1 instanceof Date) date1 = getYearMonthDay(date1);
  if (date2 instanceof Date) date2 = getYearMonthDay(date2);
  const keys = ['year', 'month', 'date'];
  return keys.every((key) => date1[key] === date2[key]);
};

const months = computed(() => {
  const ans = [];
  let { year: minYear, month: minMonth } = getYearMonthDay(minDate.value);
  const { year: maxYear, month: maxMonth } = getYearMonthDay(maxDate.value);
  const calcType = (year: number, month: number, date: number): TDateType => {
    const curDate = new Date(year, month, date, 23, 59, 59);

    if (props.type === 'single') {
      if (isSameDate({ year, month, date }, selectedDate.value)) return 'selected';
    }
    if (props.type === 'multiple') {
      const hit = selectedDate.value.some((item: Date) => isSameDate({ year, month, date }, item));
      if (hit) {
        return 'selected';
      }
    }
    if (props.type === 'range') {
      if (Array.isArray(selectedDate.value)) {
        const [startDate, endDate] = selectedDate.value;

        if (startDate && isSameDate({ year, month, date }, startDate)) return 'start';
        if (endDate && isSameDate({ year, month, date }, endDate)) return 'end';
        if (startDate && endDate && curDate.getTime() > startDate.getTime() && curDate.getTime() < endDate.getTime())
          return 'centre';
      }
    }

    const minCurDate = new Date(year, month, date, 0, 0, 0);
    if (curDate.getTime() < minDate.value.getTime() || minCurDate.getTime() > maxDate.value.getTime()) {
      return 'disabled';
    }
    return '';
  };

  while (minYear < maxYear || (minYear === maxYear && minMonth <= maxMonth)) {
    const target = getMonthDates(getDate(minYear, minMonth, 1));
    const months: TDate[] = [];
    for (let i = 1; i <= 31; i++) {
      if (i > target.lastDate) break;
      const dateObj: TDate = {
        date: getDate(minYear, minMonth, i),
        day: i,
        type: calcType(minYear, minMonth, i),
      };
      months.push(props.format ? props.format(dateObj) : dateObj);
    }
    ans.push({
      year: minYear,
      month: minMonth,
      months,
      weekdayOfFirstDay: target.weekdayOfFirstDay,
    });
    const curDate = getYearMonthDay(getDate(minYear, minMonth + 1, 1));
    minYear = curDate.year;
    minMonth = curDate.month;
  }

  return ans;
});

watch(
  valueRef,
  () => {
    if (Array.isArray(valueRef.value)) {
      selectedDate.value = valueRef.value.map((item) => new Date(item));
    } else if (valueRef.value) {
      selectedDate.value = new Date(valueRef.value);
    } else {
      selectedDate.value = props.type === 'multiple' ? [new Date()] : new Date();
    }
  },
  { immediate: true },
);
defineExpose({
  valueRef,
  templateRef,
});
</script>
